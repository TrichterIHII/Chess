<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <title>Schach gegen Bot (10 Stärken)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" href="https://unpkg.com/chessboardjs@1.0.0/www/css/chessboard.css" />
  <style>
    body{font-family:Arial,Helvetica,sans-serif;display:flex;gap:20px;padding:20px}
    #board{width:420px}
    #controls{max-width:480px}
    button{margin:6px 0;padding:8px}
    pre{background:#f5f5f5;padding:10px;border-radius:6px;overflow:auto}
  </style>
</head>
<body>
  <div>
    <div id="board"></div>
  </div>

  <div id="controls">
    <h3>Schach gegen Bot</h3>
    <label>Seite:
      <select id="side">
        <option value="white" selected>Weiß (du)</option>
        <option value="black">Schwarz (du)</option>
      </select>
    </label>
    <div>
      <button id="newBtn">Neues Spiel</button>
      <button id="undoBtn">Rückgängig</button>
    </div>

    <div>
      <label>Stärke:
        <select id="strength">
          <option value="1">1 (sehr leicht)</option>
          <option value="2">2</option>
          <option value="3">3</option>
          <option value="4">4</option>
          <option value="5">5</option>
          <option value="6">6</option>
          <option value="7">7</option>
          <option value="8">8</option>
          <option value="9">9</option>
          <option value="10">10 (Stockfish)</option>
        </select>
      </label>
    </div>

    <div>
      <strong>Letzter Zug</strong>
      <pre id="lastMove">-</pre>
    </div>

    <div>
      <strong>Notierung (PGN)</strong>
      <pre id="pgn">-</pre>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/1.0.0/chess.min.js"></script>
  <script src="https://unpkg.com/chessboardjs@1.0.0/www/js/chessboard.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/stockfish/stockfish.js"></script>
  <script>
    // Setup
    const game = new Chess();
    const boardConfig = {
      draggable: true,
      position: 'start',
      onDragStart: onDragStart,
      onDrop: onDrop,
      onSnapEnd: onSnapEnd,
      pieceTheme: 'https://unpkg.com/chessboardjs@1.0.0/www/img/chesspieces/wikipedia/{piece}.png'
    };
    const board = Chessboard('board', boardConfig);

    const lastMoveEl = document.getElementById('lastMove');
    const pgnEl = document.getElementById('pgn');
    const newBtn = document.getElementById('newBtn');
    const undoBtn = document.getElementById('undoBtn');
    const sideSelect = document.getElementById('side');
    const strengthSelect = document.getElementById('strength');

    newBtn.onclick = startNew;
    undoBtn.onclick = undoMove;

    // Stockfish Worker
    let stockfish = null;
    function initStockfish() {
      stockfish = Stockfish();
      stockfish.onmessage = function(event) {
        const line = (typeof event === "string") ? event : event.data;
        if (line.startsWith("bestmove")) {
          const parts = line.split(" ");
          if (parts[1] && parts[1] !== "(none)") {
            const move = game.move({from: parts[1].substring(0,2), to: parts[1].substring(2,4), promotion: 'q'});
            board.position(game.fen());
            updateUI(move);
          }
        }
      };
    }
    initStockfish();

    // Drag rules
    function onDragStart(source, piece, position, orientation) {
      if (game.game_over()) return false;
      const playerSide = sideSelect.value;
      if ((game.turn() === 'w' && playerSide === 'black') || (game.turn() === 'b' && playerSide === 'white')) {
        return false;
      }
      if ((game.turn() === 'w' && piece.startsWith('b')) ||
          (game.turn() === 'b' && piece.startsWith('w'))) {
        return false;
      }
    }

    function onDrop(source, target) {
      const move = game.move({ from: source, to: target, promotion: 'q' });
      if (move === null) return 'snapback';
      updateUI(move);
      setTimeout(maybeBotMove, 150);
    }

    function onSnapEnd() {
      board.position(game.fen());
    }

    function updateUI(lastMove) {
      lastMoveEl.textContent = (lastMove && lastMove.san) ? lastMove.san : '-';
      pgnEl.textContent = game.pgn() || '-';
    }

    function startNew() {
      game.reset();
      board.start();
      updateUI();
      if (sideSelect.value === 'black') setTimeout(maybeBotMove, 200);
    }

    function undoMove() {
      game.undo();
      game.undo();
      board.position(game.fen());
      updateUI();
    }

    // Einfacher Evaluator
    const pieceValues = { p: 100, n: 320, b: 330, r: 500, q: 900, k: 20000 };
    function evaluateBoard(g) {
      if (g.in_checkmate()) return g.turn() === 'w' ? -999999 : 999999;
      if (g.in_draw() || g.in_stalemate() || g.in_threefold_repetition()) return 0;
      let score = 0;
      for (const row of g.board()) {
        for (const piece of row) {
          if (piece) {
            const val = pieceValues[piece.type] || 0;
            score += piece.color === 'w' ? val : -val;
          }
        }
      }
      return score;
    }

    function minimax(g, depth, alpha, beta, isMaximizing) {
      if (depth === 0 || g.game_over()) return evaluateBoard(g);
      const moves = g.moves();
      if (isMaximizing) {
        let maxEval = -Infinity;
        for (const m of moves) {
          g.move(m);
          const evalScore = minimax(g, depth-1, alpha, beta, false);
          g.undo();
          if (evalScore > maxEval) maxEval = evalScore;
          if (evalScore > alpha) alpha = evalScore;
          if (beta <= alpha) break;
        }
        return maxEval;
      } else {
        let minEval = Infinity;
        for (const m of moves) {
          g.move(m);
          const evalScore = minimax(g, depth-1, alpha, beta, true);
          g.undo();
          if (evalScore < minEval) minEval = evalScore;
          if (evalScore < beta) beta = evalScore;
          if (beta <= alpha) break;
        }
        return minEval;
      }
    }

    function computeBestMove(depth) {
      const g = new Chess(game.fen());
      const moves = g.moves();
      let bestMove = null;
      let bestEval = game.turn() === 'w' ? -Infinity : Infinity;
      const isWhiteTurn = game.turn() === 'w';
      for (const m of moves) {
        g.move(m);
        const evalScore = minimax(g, depth-1, -Infinity, Infinity, !isWhiteTurn);
        g.undo();
        if (isWhiteTurn) {
          if (evalScore > bestEval) { bestEval = evalScore; bestMove = m; }
        } else {
          if (evalScore < bestEval) { bestEval = evalScore; bestMove = m; }
        }
      }
      return bestMove;
    }

    function maybeBotMove() {
      if (game.game_over()) return;
      const playerSide = sideSelect.value;
      const botColor = playerSide === 'white' ? 'b' : 'w';
      if (game.turn() !== botColor) return;

      const strength = parseInt(strengthSelect.value,10);
      if (strength < 10) {
        const depth = Math.max(1, strength); // 1-9
        const best = computeBestMove(depth);
        if (best) {
          const move = game.move(best);
          board.position(game.fen());
          updateUI(move);
        }
      } else {
        // Stockfish
        stockfish.postMessage("position fen " + game.fen());
        stockfish.postMessage("go depth 12"); // hier Stärke anpassen
      }
    }

    startNew();
  </script>
</body>
</html>
