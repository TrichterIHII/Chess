<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <title>Schach gegen Bot (mobil)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.css" />
  <style>
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      background: #000;
      color: #9cf;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
    }
    #board {
      width: 95vw;
      max-width: 500px;
      margin: 20px auto;
      box-shadow: 0 0 20px #0af;
    }
    #controls {
      width: 95vw;
      max-width: 500px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-bottom: 20px;
    }
    label {
      font-size: 1rem;
    }
    select, button {
      width: 100%;
      padding: 12px;
      font-size: 1rem;
      border: none;
      border-radius: 6px;
      background: #024;
      color: #9cf;
    }
    button {
      background: #06c;
      color: #fff;
      font-weight: bold;
    }
    button:active {
      background: #048;
    }
    pre {
      background: #111;
      color: #0cf;
      padding: 10px;
      border-radius: 6px;
      overflow-x: auto;
      font-size: 0.9rem;
    }
  </style>
</head>
<body>
  <div id="board"></div>

  <div id="controls">
    <label>Seite:
      <select id="side">
        <option value="white" selected>Weiß (du)</option>
        <option value="black">Schwarz (du)</option>
      </select>
    </label>

    <label>Stärke:
      <select id="strength">
        <option value="1">1 (leicht)</option>
        <option value="2">2</option>
        <option value="3">3</option>
        <option value="4">4</option>
        <option value="5">5</option>
        <option value="6">6</option>
        <option value="7">7</option>
        <option value="8">8</option>
        <option value="9">9</option>
        <option value="10">10 (Stockfish)</option>
      </select>
    </label>

    <button id="newBtn">Neues Spiel</button>
    <button id="undoBtn">Rückgängig</button>

    <strong>Letzter Zug:</strong>
    <pre id="lastMove">-</pre>

    <strong>Notierung (PGN):</strong>
    <pre id="pgn">-</pre>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.13.4/chess.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chessboard-js/1.0.0/chessboard-1.0.0.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/stockfish/stockfish.js"></script>
  <script>
    const game = new Chess();
    const board = Chessboard('board', {
      draggable: true,
      position: 'start',
      onDrop: onDrop
    });

    const lastMoveEl = document.getElementById('lastMove');
    const pgnEl = document.getElementById('pgn');
    const newBtn = document.getElementById('newBtn');
    const undoBtn = document.getElementById('undoBtn');
    const sideSelect = document.getElementById('side');
    const strengthSelect = document.getElementById('strength');

    newBtn.onclick = startNew;
    undoBtn.onclick = undoMove;

    let stockfish = Stockfish();
    stockfish.onmessage = function(event) {
      const line = (typeof event === "string") ? event : event.data;
      if (line.startsWith("bestmove")) {
        const parts = line.split(" ");
        if (parts[1] && parts[1] !== "(none)") {
          const move = game.move({
            from: parts[1].substring(0,2),
            to: parts[1].substring(2,4),
            promotion: 'q'
          });
          board.position(game.fen());
          updateUI(move);
        }
      }
    };

    function onDrop(source, target) {
      const move = game.move({ from: source, to: target, promotion: 'q' });
      if (move === null) return 'snapback';
      updateUI(move);
      setTimeout(maybeBotMove, 200);
    }

    function updateUI(move) {
      lastMoveEl.textContent = (move && move.san) ? move.san : "-";
      pgnEl.textContent = game.pgn() || "-";
    }

    function startNew() {
      game.reset();
      board.start();
      updateUI();
      if (sideSelect.value === 'black') setTimeout(maybeBotMove, 300);
    }

    function undoMove() {
      game.undo();
      game.undo();
      board.position(game.fen());
      updateUI();
    }

    const pieceValues = { p: 100, n: 320, b: 330, r: 500, q: 900, k: 20000 };
    function evaluateBoard(g) {
      if (g.in_checkmate()) return g.turn() === 'w' ? -999999 : 999999;
      if (g.in_draw() || g.in_stalemate() || g.in_threefold_repetition()) return 0;
      let score = 0;
      for (const row of g.board()) {
        for (const piece of row) {
          if (piece) {
            const val = pieceValues[piece.type] || 0;
            score += piece.color === 'w' ? val : -val;
          }
        }
      }
      return score;
    }

    function minimax(g, depth, alpha, beta, isMaximizing) {
      if (depth === 0 || g.game_over()) return evaluateBoard(g);
      const moves = g.moves();
      if (isMaximizing) {
        let maxEval = -Infinity;
        for (const m of moves) {
          g.move(m);
          const evalScore = minimax(g, depth-1, alpha, beta, false);
          g.undo();
          if (evalScore > maxEval) maxEval = evalScore;
          if (evalScore > alpha) alpha = evalScore;
          if (beta <= alpha) break;
        }
        return maxEval;
      } else {
        let minEval = Infinity;
        for (const m of moves) {
          g.move(m);
          const evalScore = minimax(g, depth-1, alpha, beta, true);
          g.undo();
          if (evalScore < minEval) minEval = evalScore;
          if (evalScore < beta) beta = evalScore;
          if (beta <= alpha) break;
        }
        return minEval;
      }
    }

    function computeBestMove(depth) {
      const g = new Chess(game.fen());
      const moves = g.moves();
      let bestMove = null;
      let bestEval = game.turn() === 'w' ? -Infinity : Infinity;
      const isWhiteTurn = game.turn() === 'w';
      for (const m of moves) {
        g.move(m);
        const evalScore = minimax(g, depth-1, -Infinity, Infinity, !isWhiteTurn);
        g.undo();
        if (isWhiteTurn) {
          if (evalScore > bestEval) { bestEval = evalScore; bestMove = m; }
        } else {
          if (evalScore < bestEval) { bestEval = evalScore; bestMove = m; }
        }
      }
      return bestMove;
    }

    function maybeBotMove() {
      if (game.game_over()) return;
      const playerSide = sideSelect.value;
      const botColor = playerSide === 'white' ? 'b' : 'w';
      if (game.turn() !== botColor) return;

      const strength = parseInt(strengthSelect.value,10);
      if (strength < 10) {
        const depth = Math.max(1, strength);
        const best = computeBestMove(depth);
        if (best) {
          const move = game.move(best);
          board.position(game.fen());
          updateUI(move);
        }
      } else {
        stockfish.postMessage("position fen " + game.fen());
        stockfish.postMessage("go depth 12");
      }
    }

    startNew();
  </script>
</body>
</html>
